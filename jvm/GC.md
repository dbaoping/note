## 前言

GC 即 Garbage Collection，中文 意思“垃圾回收”，在有GC之前，我们手动去管理内存，如果你忘记标记某一处已经不再使用的内存，那么这块内存将永远不会被系统回收，也就是常说的 “内存泄露”。

> 以下所有的 GC 介绍，全部基于主流 JVM 虚拟机 Hotspot。

## GC的基础知识

### 一 、什么是垃圾

没有任何引用指向的一个对象或者多个对象（循环引用）

### 二、 如何定位垃圾

#### 1. 引用计数（ReferenceCount）

> 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可再被使用的。这样实现优点是高效、简单，但是缺点也很明显：无法解决循环依赖

#### 2. 可达性分析算法(RootSearching)

 > 将一系列的 GC Roots 对象作为起点，开始向下搜索。从这些节点开始，根据引用关系向下搜索，搜索过
 > 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，
 > 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
    参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如
    NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

#### 3. 再谈引用

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软
引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强
度依次逐渐减弱。

- 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。
- 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

#### 4. 回收方法区

垃圾收集行为在这个区域的比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

- 废弃的常量
- 不再使用的类型
    - 加载该类的类加载器已被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如
        OSGi、JSP的重加载等，否则通常是很难达成的。
    - 该类的所有实例已被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
    - 该类的java.lang.Class没有在任何地方被引用，即无法通过反射访问该类的方法

#### 5. finalize() 方法

如果对象在进行可达性分析后发现没与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用，那么虚拟机将这两种情况都视为“没有必要执行”。

一个对象的finallze方法只会被执行一次，并且不会保证其一定会执行完成，并且何时执行。

不推荐使用finalize(）对对象进行自救。

### 三、 常见的垃圾回收算法

#### 1. 标记清除(Mark-Sweep)

如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程

**缺点：**

> 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
>
> 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 2. 标记复制算法 (Semispace Copying) 

将可用按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着
的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存
活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复
制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有
空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，

**缺点：**

> 第一个是复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点

#### 3. 标记整理(Mark-Compact)

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内。解决标记清除算法碎片化问题。

**缺点：**

>效率偏低，移动操作必须全程暂停用户应用（Stop The World）

### 四、 JVM内存分代模型（用于分代垃圾回收算法）

#### 1. 部分垃圾回收器使用的模型

![image](https://raw.githubusercontent.com/dbaoping/note/master/pic/0c2438d7-e471-3129-8a16-ae7f2ba46d86.png)

   > 1、除Epsilon、ZGC、Shenandoah之外的GC都是使用逻辑分代模型
   >
   > 2、G1是逻辑分代，物理不分代
   >
   > 3、除此之外不仅逻辑分代，而且物理分代

- **部分收集（Partial GC）**

    指目标不是完整收集整个Java堆的垃圾收集，其中又分为：

    - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
    - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
    - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

- **整堆收集（Full GC）**

    收集整个Java堆和方法区的垃圾收集。Full GC 的触发条件有以下几种
    
    > 1、System.gc()方法的调用
    > 2、老年代空间不足
    > 3、方法区空间不足
    > 4、通过Minor GC后进入老年代的平均大小大于老年代的可用内存

#### 2. 进入老年代的条件

- 大对象直接进入老年代，可通过-XX：PretenureSizeThreshold参数设置。

- 长期存活的对象进入老年代，默认值15（CMS垃圾收集器是6）。对象的年龄存放在markword里。

- 动态年龄：（不重要）

    > Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
    >
    > -XX:TargetSurvivorRatio 默认50%
    >
    > 算的是年龄从小到大的累加和，而不是某个年龄段对象的大小。

- 分配担保：（不重要）

    在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总
    空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-
    XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允
    许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大
    于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：
    HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
    
    > 在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。在Serial+Serial Old的情况下，发现放不下就直接启动担保机制；在Parallel Scavenge+Serial Old的情况下，却是先要去判断一下要分配的内存是不是>=Eden区大小的一半，如果是那么直接把该对象放入老生代，否则才会启动担保机制。

## 常见的垃圾回收器

![常用垃圾回收器](https://raw.githubusercontent.com/dbaoping/note/master/pic/5977533-fa8825a29a577899.jpg)

### 一、 Serial 收集器

![image-20200328173349883](https://raw.githubusercontent.com/dbaoping/note/master/pic/image-20200328173349883.png)

- 使用复制算法，只能用于新生代。
- 这个收集器是一个单线程工作的收集器。
- 回收过程中会造成STW（Stop the World）
- 相比其他收集器，Serial额外内存消耗最小，没有其他线程交互的开销，单线程收集效率最高。

### 二、 ParNew 收集器

![image](https://raw.githubusercontent.com/dbaoping/note/master/pic/image-20200328173752465.png)

- Serial收集器的多线程版本。控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致
- 主要适用于server端，与CMS配合使用。

### 三、 Parallel Scavenge 收集器

- 使用于标记-复制算法，用于新生代的多线程垃圾收集器。

- 利用-XX：MaxGCPauseMillis参数（最大垃圾收集停顿时间）和-XX：GCTimeRatio参数（吞吐量大小）

    两个参数来达到一个可控制的吞吐量

- 自适应的调节策略（GC Ergonomics）：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时或者最大的吞吐量。参数-XX：+UseAdaptiveSizePolicy。

### 四、 Serial Old 收集器

- Serial收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法，
- 适用于Client端，如果在server模式下，它也可能有两种用：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另外一种就是作为CMS器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### 五、 Parallel Old 收集器

- Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。
- 在注重或者处理器资源较为稀缺的场合，可以优先考虑Parallel Scavenge加Parallel Old这个组合。

### 六、 ConcurrentMarkSweep（CMS）收集器 

- 一种以获取最短回收停顿时间为目标的收集器

- 基于标记-清除算法实现，会产生碎片。

- 收集过程

    - 初始标记（CMS initial mark）

        > 初始标记仅仅只是标记一下GC能直接关联到的对象，速度很快；会引起STW。

    - 并发标记（CMS concurrent mark）

        > 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；

    - 重新标记（CMS remark）

        > 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的记录，这个阶段的停顿时间通常会比初始标记阶段稍长一，但也远比并发标记阶段的时间短。

    - 并发清除（CMS concurrent sweep）

        > 清理删除掉标记阶段判断的已经死亡的
        > 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

- ![image-20200329161730359](https://raw.githubusercontent.com/dbaoping/note/master/pic/image-20200329161730359.png)
	
- 缺点

    - 对CPU敏感

        >并发阶段会占用一部分CPU资源而导致应用程序变慢，降低总吞吐量。

    - 无法处理浮动垃圾（Floating Garbage）

        > 并发标记和并发清理阶段有新的垃圾对象不断产生，但这一部分对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集再清理掉。
        >
        > CMS收集器不能像其他收集器那样等待老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。可通过参数-XX:CMSInitiatingOccupancyFraction来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。值太高了面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。

    - 碎片化问题

        > 为了解决碎片问题，收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认是开启的，此参数从9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBefore（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表每次进入Full GC时都进行碎片整理）。

### 七、 G1 收集器(200ms - 10ms)

G1将JAVA堆划分成多个大小相等的独立区域（Region），虽然保留了新生代和老年代的概念，但是它们已经不再是物理隔离了，而都是一部分Region的集合。G1在后台维护一个 优先列表，这个列表中保存了G1收集到的各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收需要的时间的经验值），当需要进行垃圾回收的时候，根据用户允许的收集时间，优先回收列表中价值最大的那个Region（这就是Garbage-First，G1名字的由来）。这种使用Region划分空间以及根据优先级的区域回收方式，保证了G1收集器可以在有效的时间内获得尽可能高的收集效率，同时也避免了在整个JAVA堆中进行全区域的垃圾收集。

G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存碎片，垃圾收集完成之后能提供规整的可用内存。

![image-20200329190207533](https://raw.githubusercontent.com/dbaoping/note/master/pic/image-20200329190207533.png)

- 收集过程

    - 初始标记

        > 仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

    - 并发标记

        > 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以，还要重新处理SATB记录下的在并发时有引用变动的对象。

    - 最终标记

        > 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留的最后那少量的SATB记录。

    - 筛选回收

        > 负责更新Region的统计数据，对各个Region的回价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行的。

- 缺点

    - 内存占用高
    - 程序运行时的额外执行负载高
> 
 算法：三色标记 + SATB
### 八、 ZGC 收集器 (10ms - 1ms) PK C++
    算法：ColoredPointers + LoadBarrier
### 九、 Shenandoah收集器
    算法：ColoredPointers + WriteBarrier
### 十、 Eplison

这是一款以不能够进行垃圾为“卖点”的垃圾收集器。如果的应用只要运行数分钟甚至数秒，Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为，Epsilon便是很恰当的选择。

### 十一、常见垃圾回收器组合参数设定：(1.8)

**1.8默认的垃圾回收：Parallel Scavenge + ParallelOld**

* -XX:+UseSerialGC = Serial New (DefNew) + Serial Old

  > 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器
* -XX:+UseParNewGC = ParNew + SerialOld

  > 这个组合已经很少用（在某些版本中已经废弃）
* -XX:+UseConcMarkSweepGC = ParNew + CMS + Serial Old
* -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】
* -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old
* -XX:+UseG1GC = G1
* Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC 
  * java +XX:+PrintCommandLineFlags -version
  * 通过GC的日志来分辨

* Linux下1.8版本默认的垃圾回收器到底是什么？

  * 1.8.0_181 默认（看不出来）CopyMarkCompact
  * 1.8.0_222 默认 PS + PO
