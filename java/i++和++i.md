## i++、++i在jvm层面执行

### 1、程序

```java
public static void main(String[] args) {
    int j = 0;
    for (int i = 0; i < 10; i++) {
        j = (j++);
    }
    System.out.println(j);
}
```

### 2、运行结果

```0```

### 3、原理分析

#### 3.1、反编译

```
javap -c xxx.class
```

#### 3.2、反编译结果

```
public static void main(java.lang.String[]);
    Code:
       0: iconst_0    // 将常数0压入到操作数栈顶
       1: istore_1    // 将操作数栈顶元素弹出并压入到局部变量表中1号槽位，也就是j=0
       2: iconst_0    // 将常数0压入到操作数栈顶
       3: istore_2    // 将操作数栈顶元素弹出并压入到局部变量表中2号槽位，也就是i=0
       4: iload_2     // 将2号槽位的元素压入操作数栈顶
       5: bipush        10   // 将常数10压入到操作数栈顶，此时操作数栈中有两个数（常数10，以及i）
       7: if_icmpge     21   // 比较操作数栈中的两个数，如果i>=10,跳转到第21行
      10: iload_1    // 将局部变量表中的1号槽位的元素压入到操作数栈顶，就是将j=0压入操作数栈顶
      11: iinc          1, 1 // 将局部变量表中的1号元素自增1，此时局部变量表中的j=1
      14: istore_1    // 将操作数栈顶的元素（此时栈顶元素为0）弹出并赋值给局部变量表中的1号槽位（一号槽位本来已经完成自增了，但是又被赋值成了0）
      15: iinc          2, 1 // 将局部变量表中的2号槽位的元素自增1，此时局部变量表中的2号元素值为1，也就是i=1
      18: goto          4   // 第一次循环结束，跳转到第四行继续循环
      21: getstatic     #2  // Field java/lang/System.out:Ljava/io/PrintStream;
      24: iload_1
      25: invokevirtual #3  // Method java/io/PrintStream.println:(I)V
      28: return


```

#### 3.3、解析

**iinc指令是直接对局部变量进行自增**，但是在进行赋值时是将操作数栈中的数据弹出，但是操作数栈的数据并没有经过计算，所以每次自增的结果都被覆盖了。最终结果就是0。

我们平常说的i++是先拿去用，然后再自增，而++i是先自增再拿去用。这个到底怎么理解呢？如果站在JVM的层次来讲的话，应该这样说：

>1. i++是先被操作数栈拿去用了（先执行的load指令），然后再在局部变量表中完成了自增，但是操作数栈中还是自增前的值
>2. 而++1是先在局部变量表中完成了自增（先执行innc指令），然后再被load进了操作数栈，所以操作数栈中保存的是自增后的值